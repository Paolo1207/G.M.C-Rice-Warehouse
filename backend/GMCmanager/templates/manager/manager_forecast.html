<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title id="pageTitle">Forecast - G.M.C. Rice Warehouse</title>

  <!-- Manager static assets -->
  <link rel="stylesheet" href="{{ url_for('manager.static', filename='css/main.css') }}">
  <link rel="stylesheet" href="{{ url_for('manager.static', filename='css/forecast.css') }}">
  <style>
    .branch-pill {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: #e8f5e9;
      color: #2e7d32;
      padding: 0.5rem 1rem;
      border-radius: 20px;
      font-size: 0.875rem;
      font-weight: 500;
      border: 1px solid #c8e6c9;
      margin-left: 1rem;
    }
    
    .branch-pill i {
      font-size: 0.75rem;
    }
    
    .forecast-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .forecast-actions {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
    }
    
    .btn.primary {
      background: #2e7d32;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
    }
    
    .btn.primary:hover {
      background: #27642a;
    }
    
    .btn.secondary {
      background: #f5f5f5;
      color: #333;
      border: 1px solid #ddd;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 500;
      transition: background 0.2s;
    }
    
    .btn.secondary:hover {
      background: #e9ecef;
    }
    
    
    .risk-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
    }
    
    .risk-table-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 1rem;
    }
    
    .forecast-actions {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      flex-wrap: wrap;
    }
    
    /* Risk styling */
    .risk-type {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
    }
    
    .risk-type.shortage {
      background: #fee2e2;
      color: #dc2626;
    }
    
    .risk-type.overstock {
      background: #fef3c7;
      color: #d97706;
    }
    
    .risk-type.balanced {
      background: #d1fae5;
      color: #059669;
    }
    
    .risk-badge {
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 500;
      text-transform: uppercase;
    }
    
    .risk-badge.critical {
      background: #fecaca;
      color: #b91c1c;
    }
    
    .risk-badge.moderate {
      background: #fed7aa;
      color: #c2410c;
    }
    
    .risk-badge.low {
      background: #bbf7d0;
      color: #166534;
    }
    
    .empty-state {
      text-align: center;
      padding: 2rem;
      color: #666;
    }
  </style>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
</head>
<body>
  <div class="container">
    <!-- Navigation -->
    <nav class="navbar">
      <div class="nav-brand">
        <h1 id="branchTitle">G.M.C. Rice Warehouse</h1>
      </div>

      <div class="nav-main">
        <div class="nav-section">
          <h2>Main Menu</h2>
          <ul>
            <li><a href="{{ url_for('manager.manager_dashboard') }}"><i class="fas fa-home"></i> Dashboard</a></li>
            <li><a href="{{ url_for('manager.inventory') }}"><i class="fas fa-box"></i> Inventory</a></li>
            <li><a href="{{ url_for('manager.forecast') }}" class="active"><i class="fas fa-chart-line"></i> Forecast</a></li>
            <li><a href="{{ url_for('manager.sales') }}"><i class="fas fa-shopping-cart"></i> Sales</a></li>
            <li><a href="{{ url_for('manager.purchase') }}"><i class="fas fa-shopping-bag"></i> Purchase</a></li>
          </ul>
        </div>

        <div class="nav-section">
          <h2>Reports</h2>
          <ul>
            <li><a href="{{ url_for('manager.reports') }}"><i class="fas fa-file-alt"></i> All Reports</a></li>
            <li><a href="{{ url_for('manager.analytics') }}"><i class="fas fa-chart-bar"></i> Analytics</a></li>
          </ul>
        </div>

        <div class="nav-section">
          <h2>Settings</h2>
          <ul>
            <li><a href="{{ url_for('manager.notifications') }}"><i class="fas fa-bell"></i> Notifications</a></li>
            <li><a href="{{ url_for('manager.settings') }}"><i class="fas fa-cog"></i> Account Settings</a></li>
          </ul>
        </div>
      </div>
    </nav>

    <!-- Main Content -->
    <main class="main-content">
      <div class="forecast-container">
        <div class="forecast-header">
          <h2><i class="fas fa-chart-line"></i> <span id="pageTitle">Forecast</span></h2>
        </div>

        <div class="forecast-tabs">
          <button class="tab-btn active" data-tab="demand">
            <i class="fas fa-chart-bar"></i> Demand Forecast
          </button>
          <button class="tab-btn" data-tab="price">
            <i class="fas fa-tag"></i> Price Forecast
          </button>
          <button class="tab-btn" data-tab="risk">
            <i class="fas fa-exclamation-triangle"></i> Stock Risk
          </button>
        </div>

        <!-- Demand Forecast Tab -->
        <div class="tab-content active" id="demand-forecast">
          <div class="forecast-filters">
            <div class="filter-group">
              <select id="productFilter">
                <option value="">All Products</option>
                <!-- Products will be populated from inventory -->
              </select>
            </div>
            <div class="date-range">
              <select id="timeRange">
                <option value="7">Last 7 Days</option>
                <option value="30">Last 30 Days</option>
                <option value="90">Next Month</option>
              </select>
            </div>
            <div class="forecast-actions">
              <button class="btn primary" onclick="generateForecast()">
                <i class="fas fa-magic"></i> Generate Demand Forecast
              </button>
              <button class="btn secondary" onclick="exportForecast()">
                <i class="fas fa-download"></i> Export Report
              </button>
            </div>
          </div>

          <div class="forecast-grid">
            <div class="forecast-chart">
              <h3><i class="fas fa-chart-line"></i> Demand Forecast</h3>
              <canvas id="demandChart"></canvas>
            </div>

            <div class="forecast-summary">
              <h3><i class="fas fa-info-circle"></i> Forecast Summary</h3>
              <div class="summary-cards">
                <div class="summary-card">
                  <h4>Average Demand</h4>
                  <p class="number">--</p>
                  <p class="trend">
                    No forecast generated yet
                  </p>
                </div>
                <div class="summary-card">
                  <h4>Peak Day</h4>
                  <p class="date">--</p>
                  <p class="quantity">--</p>
                </div>
                <div class="summary-card">
                  <h4>Suggested Reorder</h4>
                  <p class="number">--</p>
                  <p class="trend">Generate forecast first</p>
                </div>
              </div>
            </div>
          </div>

          <!-- Forecast Information & Stock Preparation Guide -->
          <div class="glass-card" id="forecast-information" style="display: none; margin-top: 2rem; padding: 2rem; background: rgba(255, 255, 255, 0.95); border-radius: 12px; box-shadow: 0 4px 16px rgba(0,0,0,0.1);">
            <h3 style="font-size: 1.18rem; font-weight: 700; color: #1a365d; margin: 0 0 20px 0;">
              ðŸ“– Forecast Interpretation & Stock Preparation Guide
            </h3>
            <div id="forecast-information-content"></div>
          </div>
        </div>

        <!-- Price Forecast Tab -->
        <div class="tab-content" id="price-forecast">
          <div class="forecast-filters">
            <div class="filter-group">
              <select id="priceProductFilter">
                <option value="">All Products</option>
                <!-- Products will be populated from inventory -->
              </select>
              <select id="priceTimeRange">
                <option value="30">Last 30 Days</option>
                <option value="90">Last 3 Months</option>
                <option value="180">Last 6 Months</option>
              </select>
            </div>
            <div class="forecast-actions">
              <button class="btn primary" onclick="generatePriceForecast()">
                <i class="fas fa-chart-line"></i> Generate Price Forecast
              </button>
            </div>
          </div>

          <div class="forecast-grid">
            <div class="forecast-chart">
              <h3><i class="fas fa-chart-line"></i> Price Movement</h3>
              <canvas id="priceChart"></canvas>
            </div>
            <div class="price-insights">
              <h3><i class="fas fa-lightbulb"></i> Price Insights</h3>
              <div class="insight-cards">
                <div class="insight-card">
                  <h4>Current Price</h4>
                  <p class="price">â‚±99.99/kg</p>
                  <p class="trend positive">
                    <i class="fas fa-arrow-up"></i>
                    +4% from last month
                  </p>
                </div>
                <div class="insight-card">
                  <h4>Predicted Change</h4>
                  <p class="prediction">+4%</p>
                  <p class="reason">Due to upcoming holiday</p>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Stock Risk Tab -->
        <div class="tab-content" id="risk-forecast">
          <div class="forecast-filters">
            <div class="filter-group">
              <select id="riskProductFilter">
                <option value="">All Products</option>
                <!-- Products will be populated from inventory -->
              </select>
              <select id="riskCategoryFilter">
                <option value="">All Categories</option>
                <option value="shortage">Shortage</option>
                <option value="overstock">Overstock</option>
              </select>
              <select id="riskSeverityFilter">
                <option value="">All Severity Levels</option>
                <option value="critical">Critical</option>
                <option value="moderate">Moderate</option>
                <option value="low">Low</option>
              </select>
            </div>
            <div class="date-range">
              <select id="riskDateRange">
                <option value="7">Last 7 Days</option>
                <option value="30">Last 30 Days</option>
                <option value="90">Last 3 Months</option>
              </select>
            </div>
          </div>

          <div class="risk-overview">
            <div class="risk-card critical">
              <h4><i class="fas fa-exclamation-circle"></i> Critical Risk</h4>
              <p class="number">5</p>
              <p class="description">Items requiring immediate attention</p>
            </div>
            <div class="risk-card moderate">
              <h4><i class="fas fa-exclamation-triangle"></i> Moderate Risk</h4>
              <p class="number">12</p>
              <p class="description">Items to monitor closely</p>
            </div>
            <div class="risk-card low">
              <h4><i class="fas fa-check-circle"></i> Low Risk</h4>
              <p class="number">45</p>
              <p class="description">Items in good standing</p>
            </div>
          </div>

          <div class="risk-table-container">
            <div class="risk-table-header">
              <h3><i class="fas fa-table"></i> Risk Analysis</h3>
              <div class="risk-actions">
                <button class="btn primary" onclick="generateRiskAnalysis()">
                  <i class="fas fa-exclamation-triangle"></i> Analyze Risks
                </button>
              <button class="btn secondary" onclick="exportRiskReport()">
                <i class="fas fa-download"></i> Export Report
              </button>
              </div>
            </div>
            <table class="risk-table">
              <thead>
                <tr>
                  <th>Product</th>
                  <th>Risk Type</th>
                  <th>Severity Level</th>
                  <th>Current Stock</th>
                  <th>Threshold</th>
                  <th>Suggested Action</th>
                </tr>
              </thead>
              <tbody id="riskTableBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </main>
  </div>

  <!-- Scripts -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="{{ url_for('manager.static', filename='js/main.js') }}"></script>
  <script>
    // Manager branch scoping
    let MANAGER_BRANCH_ID = null;
    let MANAGER_BRANCH_NAME = null;
    let demandChart, priceChart;
    
    // Forecast control
    let filtersDirty = false;
    let activeForecastController = null;

    // Initialize page
    document.addEventListener('DOMContentLoaded', () => {
      initializeManagerForecast();
      initCharts(); // Initialize charts
      
      // Ensure chart is ready
      setTimeout(() => {
        console.log('Chart initialization check:', {
          demandChart: !!demandChart,
          chartElement: !!document.getElementById('demandChart')
        });
        
      }, 1000);
    });

    async function initializeManagerForecast() {
      try {
        // Get manager's branch from URL or session
        const urlParams = new URLSearchParams(window.location.search);
        MANAGER_BRANCH_ID = urlParams.get('branch') || null;
        MANAGER_BRANCH_NAME = urlParams.get('branch_name') || null;
        
        // If no branch in URL, get from manager API
        if (!MANAGER_BRANCH_ID) {
          await loadManagerBranch();
        }
        
        setupTabs();
        updateHeaderTitle('demand'); // Set initial title for demand tab
        await loadManagerData();
      setupRiskFilters();
        updateBranchDisplay();
        
        // Clear price insights on initial load
        clearPriceInsights();
      } catch (error) {
        console.error('Error initializing manager forecast:', error);
        showToast('Error loading forecast data', 'error');
      }
    }

    async function loadManagerBranch() {
      try {
        const response = await fetch('/manager/api/branches');
        const data = await response.json();
        if (data.ok && data.branches && data.branches.length > 0) {
          MANAGER_BRANCH_ID = data.branches[0].id;
          MANAGER_BRANCH_NAME = data.branches[0].name;
        }
      } catch (error) {
        console.error('Error loading manager branch:', error);
      }
    }

    function updateBranchDisplay() {
      if (MANAGER_BRANCH_NAME) {
        const branchPill = document.createElement('div');
        branchPill.className = 'branch-pill';
        branchPill.innerHTML = `<i class="fas fa-map-marker-alt"></i> You're viewing: ${MANAGER_BRANCH_NAME}`;
        
        const forecastHeader = document.querySelector('.forecast-header');
        if (forecastHeader) {
          forecastHeader.appendChild(branchPill);
        }
      }
    }

    // Tabs
    function setupTabs() {
      const tabBtns = document.querySelectorAll('.tab-btn');
      const tabContents = document.querySelectorAll('.tab-content');

      tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const tabId = btn.getAttribute('data-tab');

          tabBtns.forEach(b => b.classList.remove('active'));
          tabContents.forEach(c => c.classList.remove('active'));

          btn.classList.add('active');
          const target = document.getElementById(`${tabId}-forecast`);
          if (target) target.classList.add('active');

          // Update header title based on active tab
          updateHeaderTitle(tabId);

          if (tabId === 'risk') {
            loadRiskData();
          } else if (tabId === 'price') {
            // Clear price insights when switching to price tab
            clearPriceInsights();
          }
        });
      });
    }

    // Update header title based on active tab
    function updateHeaderTitle(tabId) {
      const pageTitle = document.getElementById('pageTitle');
      if (!pageTitle) return;

      // Just use "Forecast" for all tabs
      pageTitle.textContent = 'Forecast';
    }

    // Initialize charts with manager data
    function initCharts() {
      // Demand Chart
      const dCtx = document.getElementById('demandChart');
      if (dCtx) {
        demandChart = new Chart(dCtx.getContext('2d'), {
        type: 'line',
        data: {
            labels: [],
          datasets: [{
            label: 'Actual Demand',
              data: [],
            borderColor: '#1a365d',
            backgroundColor: 'rgba(26, 54, 93, 0.1)',
            tension: 0.4,
            fill: true
            }, {
              label: 'Forecast',
              data: [],
              borderColor: '#e53e3e',
              backgroundColor: 'rgba(229, 62, 62, 0.1)',
              borderDash: [5, 5],
              tension: 0.4,
              fill: false
          }]
        },
        options: {
          responsive: true,
            plugins: { 
              title: { display: true, text: 'Demand Forecast' },
              legend: { 
                position: 'top',
                onClick: (e, item, legend) => Chart.defaults.plugins.legend.onClick(e, item, legend)
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Quantity (kg)' }
              },
              x: {
                title: { display: true, text: 'Date' }
              }
            }
          }
        });
      }

      // Price Chart
      const pCtx = document.getElementById('priceChart');
      if (pCtx) {
        priceChart = new Chart(pCtx.getContext('2d'), {
        type: 'line',
        data: {
            labels: [],
          datasets: [{
            label: 'Price per Unit',
              data: [],
            borderColor: '#1a365d',
            backgroundColor: 'rgba(26, 54, 93, 0.1)',
            tension: 0.4,
            fill: true
          }]
        },
        options: {
          responsive: true,
            plugins: { 
              title: { display: true, text: 'Price Movement' },
              legend: { position: 'top' }
            },
            scales: {
              y: {
                beginAtZero: true,
                title: { display: true, text: 'Price (â‚±)' }
              },
              x: {
                title: { display: true, text: 'Date' }
              }
            }
          }
        });
      }
    }

    // Apply forecast data to chart and UI components
    function applyForecast({ forecast, summary, details }) {
      console.log('Applying forecast data:', { forecast, summary, details });
      
      if (demandChart && forecast) {
        // Check if we have valid data
        const hasLabels = forecast.labels && forecast.labels.length > 0;
        const hasForecast = forecast.forecast && forecast.forecast.length > 0;
        const hasActual = forecast.actual && forecast.actual.length > 0;
        
        if (hasLabels && (hasForecast || hasActual)) {
          // Replace arrays wholesale - never mutate partially
          demandChart.data.labels = forecast.labels || [];
          demandChart.data.datasets[0].data = forecast.actual || [];
          demandChart.data.datasets[1].data = forecast.forecast || [];
          
          demandChart.update();
          console.log('Chart updated successfully');
          
          // Only update summary if we have valid data
          if (summary && summary.avg_demand > 0) {
            updateForecastSummary(summary);
          } else {
            console.log('Invalid summary data - keeping existing values');
          }
          
          // Details table removed - information is shown in the information section below
        } else {
          console.warn('Invalid forecast data - generating sample data');
          generateSampleForecastData();
        }
      } else {
        console.error('Chart or forecast data missing:', { 
          demandChart: !!demandChart, 
          forecast: !!forecast 
        });
      }
      
      filtersDirty = false;
    }

    // Generate sample forecast data for testing
    function generateSampleForecastData() {
      console.log('Generating sample forecast data...');
      
      if (!demandChart) return;
      
      const days = 7;
      const labels = [];
      const actualData = [];
      const forecastData = [];
      
      const today = new Date();
      for (let i = 0; i < days; i++) {
        const date = new Date(today);
        date.setDate(today.getDate() + i);
        labels.push(date.toISOString().split('T')[0]);
        
        // Generate sample data
        actualData.push(Math.floor(Math.random() * 100) + 50);
        forecastData.push(Math.floor(Math.random() * 120) + 60);
      }
      
      demandChart.data.labels = labels;
      demandChart.data.datasets[0].data = actualData;
      demandChart.data.datasets[1].data = forecastData;
      demandChart.update();
      
      // Update summary with sample data
      const avgDemand = Math.round(forecastData.reduce((a, b) => a + b, 0) / forecastData.length);
      const peakIndex = forecastData.indexOf(Math.max(...forecastData));
      const peakDate = labels[peakIndex];
      const peakQty = Math.max(...forecastData);
      
      
      updateForecastSummary({
        avg_demand: avgDemand,
        peak_date: peakDate,
        peak_quantity: peakQty,
        suggested_reorder: Math.round(avgDemand * 0.1),
        confidence: 85.0
      });
      
      console.log('Sample forecast data generated');
    }

    function updateForecastCharts(forecastData) {
      console.log('Updating forecast charts with data:', forecastData);
      if (demandChart && forecastData) {
        console.log('Chart exists, updating with labels:', forecastData.labels);
        demandChart.data.labels = forecastData.labels || [];
        demandChart.data.datasets[0].data = forecastData.actual || [];
        demandChart.data.datasets[1].data = forecastData.forecast || [];
        demandChart.update();
        console.log('Chart updated successfully');
      } else {
        console.log('Chart or data missing:', { demandChart: !!demandChart, forecastData: !!forecastData });
      }
    }

    function updateForecastSummary(summary) {
      if (summary) {
        const avgDemandEl = document.querySelector('.summary-card:nth-child(1) .number');
        const peakDayEl = document.querySelector('.summary-card:nth-child(2) .date');
        const peakQtyEl = document.querySelector('.summary-card:nth-child(2) .quantity');
        const reorderEl = document.querySelector('.summary-card:nth-child(3) .number');
        
        if (avgDemandEl) avgDemandEl.textContent = (summary.avg_demand || 0).toLocaleString();
        if (peakDayEl) peakDayEl.textContent = summary.peak_date || 'N/A';
        if (peakQtyEl) peakQtyEl.textContent = (summary.peak_quantity || 0).toLocaleString() + ' kg';
        if (reorderEl) reorderEl.textContent = (summary.suggested_reorder || 0).toLocaleString();
      }
    }

    // Load manager-specific data
    async function loadManagerData() {
      await Promise.all([
        loadBranchProducts(),
        // Don't auto-load forecast data - let user generate it
        loadRiskData()
      ]);
    }

    async function loadBranchProducts() {
      try {
        // Get branch_id from template variables or URL parameters
        const branchId = {{ branch_id if branch_id else 'null' }} || 
                        new URLSearchParams(window.location.search).get('branch') || 
                        new URLSearchParams(window.location.search).get('branch_id');
        
        let apiUrl = '/manager/api/inventory';
        if (branchId) {
          apiUrl += `?branch_id=${branchId}`;
        }
        
        console.log('Loading products for branch:', branchId, 'URL:', apiUrl);
        
        const response = await fetch(apiUrl);
        const data = await response.json();
        if (data.ok && data.items) {
          populateProductFilters(data.items);
        }
      } catch (error) {
        console.error('Error loading branch products:', error);
      }
    }

    function populateProductFilters(products) {
      const filters = ['productFilter', 'priceProductFilter', 'riskProductFilter'];
      filters.forEach(filterId => {
        const select = document.getElementById(filterId);
        if (select) {
          select.innerHTML = '<option value="">All Products</option>';
          products.forEach(product => {
            const option = document.createElement('option');
            option.value = product.id;
            option.textContent = product.product_name || product.name || 'Unknown Product';
            select.appendChild(option);
          });
        }
      });
    }

    // Load forecast data from manager API
    async function loadForecastData() {
      try {
        console.log('Loading forecast data...');
        const response = await fetch('/manager/api/forecast/data');
        console.log('Forecast data response status:', response.status);
        const data = await response.json();
        console.log('Forecast data received:', data);
        
        if (data.ok) {
          console.log('Applying forecast data to UI');
          applyForecast({
            forecast: data.forecast,
            summary: data.summary,
            details: data.details || []
          });
        } else {
          console.error('Error in forecast data response:', data.error);
          showToast('Error loading forecast data: ' + data.error, 'error');
        }
      } catch (error) {
        console.error('Error loading forecast data:', error);
        showToast('Error loading forecast data', 'error');
      }
    }


    // Load risk data from manager API
    async function loadRiskData() {
      try {
        const response = await fetch('/manager/api/analytics');
        const data = await response.json();
        if (data.ok && data.branch_risks) {
          updateRiskOverview(data.branch_risks);
          renderRiskTable(data.branch_risks);
        } else {
          // Show empty state if no data
          updateRiskOverview([]);
          renderRiskTable([]);
        }
      } catch (error) {
        console.error('Error loading risk data:', error);
        // Show empty state on error
        updateRiskOverview([]);
        renderRiskTable([]);
      }
    }

    // Generate demand forecast with proper abort control and debouncing
    let generateForecastTimeout = null;
    async function generateForecast() {
      if (generateForecastTimeout) {
        clearTimeout(generateForecastTimeout);
      }
      
      generateForecastTimeout = setTimeout(async () => {
        // Abort any in-flight request
        if (activeForecastController) {
          activeForecastController.abort();
        }
        activeForecastController = new AbortController();
        
        const generateBtn = document.querySelector('button[onclick="generateForecast()"]');
        const originalText = generateBtn?.textContent || '';
        
        try {
          console.log('Starting demand forecast generation...');
          showToast('Generating ARIMA demand forecast...', 'info');
          
          // Set loading state
          if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
          }
          
          const productId = document.getElementById('productFilter')?.value || '';
          const timeRange = document.getElementById('timeRange')?.value || '30';
          
          console.log('Forecast parameters:', { productId, timeRange });
          
          // Get branch_id for the API call
          const branchId = {{ branch_id if branch_id else 'null' }} || 
                          new URLSearchParams(window.location.search).get('branch') || 
                          new URLSearchParams(window.location.search).get('branch_id');
          
          const response = await fetch('/manager/api/forecast', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              product_id: productId,
              days: parseInt(timeRange),
              model_type: 'arima',
              branch_id: branchId
            }),
            signal: activeForecastController.signal
          });
          
          console.log('API Response status:', response.status);
          const data = await response.json();
          console.log('API Response data:', data);
          
          if (data.ok) {
            showToast('ARIMA demand forecast generated successfully', 'success');
            console.log('Forecast data received:', data.forecast);
            
            // Apply the forecast data directly from the API response
            applyForecast({
              forecast: data.forecast,
              summary: data.summary,
              details: data.details || []
            });
            
            // Display detailed forecast information with branch inventory
            // Always call this, even if forecast data seems invalid
            console.log('Calling displayForecastInformation with data:', data);
            await displayForecastInformation(data, branchId, productId).catch(err => {
              console.error('Error in displayForecastInformation:', err);
            });
            filtersDirty = false;
          } else {
            console.error('API Error:', data.error);
            showToast('Error generating forecast: ' + (data.error || 'Unknown error'), 'error');
          }
        } catch (error) {
          if (error.name === 'AbortError') {
            console.log('Forecast request aborted');
            return;
          }
          console.error('Error generating forecast:', error);
          showToast('Error generating forecast', 'error');
        } finally {
          // Restore button state
          if (generateBtn) {
            generateBtn.disabled = false;
            generateBtn.innerHTML = originalText;
          }
          activeForecastController = null;
        }
      }, 500); // 500ms debounce
    }

    // Generate price forecast (Holt-Winters model)
    let generatePriceForecastTimeout = null;
    async function generatePriceForecast() {
      if (generatePriceForecastTimeout) {
        clearTimeout(generatePriceForecastTimeout);
      }
      
      generatePriceForecastTimeout = setTimeout(async () => {
        const generateBtn = document.querySelector('button[onclick="generatePriceForecast()"]');
        const originalText = generateBtn?.textContent || '';
        
        try {
          console.log('Starting price forecast generation...');
          showToast('Generating Holt-Winters price forecast...', 'info');
          
          // Set loading state
          if (generateBtn) {
            generateBtn.disabled = true;
            generateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Generating...';
          }
          
          const productId = document.getElementById('priceProductFilter')?.value || '';
          const timeRange = document.getElementById('priceTimeRange')?.value || '30';
          
          console.log('DEBUG PRICE FORECAST FRONTEND: Product ID:', productId);
          console.log('DEBUG PRICE FORECAST FRONTEND: Time Range:', timeRange);
          console.log('Price forecast parameters:', { productId, timeRange });
          
          // Get branch_id for the API call
          const branchId = {{ branch_id if branch_id else 'null' }} || 
                          new URLSearchParams(window.location.search).get('branch') || 
                          new URLSearchParams(window.location.search).get('branch_id');
          
          const response = await fetch('/manager/api/forecast/price', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              product_id: productId,
              days: parseInt(timeRange),
              model_type: 'holt_winters',  // Always use Holt-Winters for price forecast
              branch_id: branchId
            })
          });
          
          console.log('Price forecast API Response status:', response.status);
          const data = await response.json();
          console.log('DEBUG PRICE FORECAST FRONTEND: API Response:', data);
          console.log('DEBUG PRICE FORECAST FRONTEND: Price forecast data:', data.price_forecast);
          console.log('DEBUG PRICE FORECAST FRONTEND: Number of products:', data.price_forecast ? data.price_forecast.length : 0);
          
          if (data.ok) {
            showToast('Holt-Winters price forecast generated successfully', 'success');
            console.log('Price forecast data received:', data);
            
            // Update chart and insights with the returned data
            if (data.price_forecast) {
              updatePriceChart(data.price_forecast);
            }
            if (data.price_insights || data.summary) {
              updatePriceInsights(data.price_insights || data.summary);
            }
          } else {
            console.error('Price forecast API Error:', data.error);
            showToast('Error generating price forecast: ' + (data.error || 'Unknown error'), 'error');
          }
        } catch (error) {
          console.error('Error generating price forecast:', error);
          showToast('Error generating price forecast', 'error');
        } finally {
          // Restore button state
          if (generateBtn) {
            generateBtn.disabled = false;
            generateBtn.innerHTML = originalText;
          }
        }
      }, 500); // 500ms debounce
    }

    // Generate risk analysis with proper loading states
    async function generateRiskAnalysis() {
      const analyzeBtn = document.querySelector('button[onclick="generateRiskAnalysis()"]');
      const originalText = analyzeBtn?.textContent || '';
      
      try {
        showToast('Analyzing stock risks...', 'info');
        
        // Set loading state
        if (analyzeBtn) {
          analyzeBtn.disabled = true;
          analyzeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing...';
        }
        
        // Get filter values
        const productId = document.getElementById('riskProductFilter')?.value || '';
        const category = document.getElementById('riskCategoryFilter')?.value || '';
        const severity = document.getElementById('riskSeverityFilter')?.value || '';
        const days = document.getElementById('riskDateRange')?.value || '30';
        
        console.log('Risk analysis parameters:', { productId, category, severity, days });
        
        // Get branch_id for the API call
        const branchId = {{ branch_id if branch_id else 'null' }} || 
                        new URLSearchParams(window.location.search).get('branch') || 
                        new URLSearchParams(window.location.search).get('branch_id');
        
        const response = await fetch('/manager/api/forecast/risk', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            product_id: productId,
            category: category,
            severity: severity,
            days: parseInt(days),
            branch_id: branchId
          })
        });
        
        const data = await response.json();
        if (data.ok) {
          showToast(`Risk analysis completed - ${data.summary.total_analyzed} products analyzed`, 'success');
          updateRiskAnalysis(data.risk_analysis, data.summary);
        } else {
          showToast('Error generating risk analysis: ' + (data.error || 'Unknown error'), 'error');
        }
      } catch (error) {
        console.error('Error generating risk analysis:', error);
        showToast('Error generating risk analysis', 'error');
      } finally {
        // Restore button state
        if (analyzeBtn) {
          analyzeBtn.disabled = false;
          analyzeBtn.innerHTML = originalText;
        }
      }
    }

    // Update price chart with forecast data
    function updatePriceChart(priceData) {
      console.log('Updating price chart with data:', priceData);
      if (priceChart && priceData && Array.isArray(priceData)) {
        const labels = priceData.map(item => {
          // Handle different date formats
          if (item.date) {
            return new Date(item.date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
          }
          return item.label || 'Unknown';
        });
        const prices = priceData.map(item => {
          // Handle different price field names
          return item.predicted_price || item.price || item.value || 0;
        });
        
        console.log('Price chart labels:', labels);
        console.log('Price chart data:', prices);
        
        // Replace arrays wholesale - never mutate partially
        priceChart.data.labels = labels;
        priceChart.data.datasets[0].data = prices;
        priceChart.update();
        console.log('Price chart updated successfully');
      } else {
        console.log('Price chart or data missing:', { priceChart: !!priceChart, priceData: !!priceData });
      }
    }

    // Clear price insights when filters change
    function clearPriceInsights() {
      console.log('Clearing price insights...');
      
      // Reset current price
      const currentPriceEl = document.querySelector('.insight-card:nth-child(1) .price');
      if (currentPriceEl) {
        currentPriceEl.textContent = 'â‚±0.00/kg';
      }
      
      // Reset price trend
      const trendEl = document.querySelector('.insight-card:nth-child(1) .trend');
      if (trendEl) {
        trendEl.className = 'trend';
        trendEl.innerHTML = '<i class="fas fa-minus"></i> No data';
      }
      
      // Reset predicted change
      const predictionEl = document.querySelector('.insight-card:nth-child(2) .prediction');
      if (predictionEl) {
        predictionEl.textContent = '0%';
      }
      
      // Reset reason
      const reasonEl = document.querySelector('.insight-card:nth-child(2) .reason');
      if (reasonEl) {
        reasonEl.textContent = 'Generate forecast to see insights';
      }
      
      console.log('Price insights cleared');
    }

    // Update price insights with forecast data
    function updatePriceInsights(insights) {
      if (!insights) return;
      
      // Update current price (first insight card)
      const currentPriceEl = document.querySelector('.insight-card:nth-child(1) .price');
      if (currentPriceEl) {
        const currentPrice = insights.current_price || insights.currentPrice || 0;
        currentPriceEl.textContent = `â‚±${currentPrice.toFixed(2)}/kg`;
      }
      
      // Update price trend (first insight card)
      const trendEl = document.querySelector('.insight-card:nth-child(1) .trend');
      if (trendEl) {
        const changePercent = insights.price_change_percent || insights.priceChangePercent || insights.trend_percent || 0;
        const isPositive = changePercent >= 0;
        const icon = isPositive ? 'fa-arrow-up' : 'fa-arrow-down';
        const className = isPositive ? 'positive' : 'negative';
        
        trendEl.className = `trend ${className}`;
        trendEl.innerHTML = `
          <i class="fas ${icon}"></i>
          ${isPositive ? '+' : ''}${changePercent.toFixed(1)}% from last period
        `;
      }
      
      // Update predicted change (second insight card)
      const predictionEl = document.querySelector('.insight-card:nth-child(2) .prediction');
      if (predictionEl) {
        const predictedChange = insights.predicted_change_percent || insights.predictedChangePercent || insights.predicted_change || 0;
        predictionEl.textContent = `${predictedChange >= 0 ? '+' : ''}${predictedChange.toFixed(1)}%`;
      }
      
      // Update reason (second insight card)
      const reasonEl = document.querySelector('.insight-card:nth-child(2) .reason');
      if (reasonEl) {
        const reason = insights.reason || insights.explanation || insights.factor || 'Based on market trends';
        reasonEl.textContent = reason;
      }
    }

    // Update risk analysis with new data
    function updateRiskAnalysis(riskData, summary) {
      // Update risk overview cards
      const criticalEl = document.querySelector('.risk-card.critical .number');
      const moderateEl = document.querySelector('.risk-card.moderate .number');
      const lowEl = document.querySelector('.risk-card.low .number');
      
      if (criticalEl) criticalEl.textContent = summary.critical_risks;
      if (moderateEl) moderateEl.textContent = summary.moderate_risks;
      if (lowEl) lowEl.textContent = summary.low_risks;
      
      // Update risk table
      renderRiskTable(riskData);
    }

    function updateRiskOverview(data) {
      if (!data || data.length === 0) {
        // Show empty state in overview cards
        const cEl = document.querySelector('.risk-card.critical .number');
        const mEl = document.querySelector('.risk-card.moderate .number');
        const lEl = document.querySelector('.risk-card.low .number');
        if (cEl) cEl.textContent = '0';
        if (mEl) mEl.textContent = '0';
        if (lEl) lEl.textContent = '0';
        return;
      }
      
      const critical = data.filter(i => i.severity === 'critical').length;
      const moderate = data.filter(i => i.severity === 'moderate').length;
      const low = data.filter(i => i.severity === 'low').length;

      const cEl = document.querySelector('.risk-card.critical .number');
      const mEl = document.querySelector('.risk-card.moderate .number');
      const lEl = document.querySelector('.risk-card.low .number');
      if (cEl) cEl.textContent = critical;
      if (mEl) mEl.textContent = moderate;
      if (lEl) lEl.textContent = low;
    }

    function renderRiskTable(data) {
      const tbody = document.getElementById('riskTableBody');
      if (!tbody) return;
      
      // Clear existing content
      tbody.innerHTML = '';
      
      // Show empty state if no data
      if (!data || data.length === 0) {
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td colspan="6" class="empty-state">
            <div style="text-align: center; padding: 2rem; color: #666;">
              <i class="fas fa-info-circle" style="font-size: 2rem; margin-bottom: 1rem; opacity: 0.5;"></i>
              <p>No risk data found for the selected filters.</p>
              <p style="font-size: 0.9rem; margin-top: 0.5rem;">Try adjusting your filters or click "Analyze Risks" to generate new analysis.</p>
            </div>
          </td>
        `;
        tbody.appendChild(tr);
        return;
      }
      
      data.forEach(item => {
        const tr = document.createElement('tr');
        
        // Use new field names from the API
        const riskType = item.risk_type || 'Balanced';
        const severity = item.severity || 'low';
        const currentStock = item.current_stock || 0;
        const threshold = item.threshold || item.warn_level || 0;
        const suggestedAction = item.suggested_action || 'Monitor';
        const daysOfCoverage = item.days_of_coverage || 0;
        const avgDailyDemand = item.avg_daily_demand || 0;
        
        tr.innerHTML = `
          <td>${item.product_name || 'Unknown Product'}</td>
          <td><span class="risk-type ${riskType.toLowerCase()}">${riskType}</span></td>
          <td><span class="risk-badge ${severity.toLowerCase()}">${severity}</span></td>
          <td>${currentStock.toLocaleString()} kg</td>
          <td>${threshold.toLocaleString()} kg</td>
          <td>${suggestedAction}</td>
        `;
        
        // Add tooltip with additional info
        tr.title = `Days of Coverage: ${daysOfCoverage} days | Avg Daily Demand: ${avgDailyDemand.toFixed(2)} kg`;
        
        tbody.appendChild(tr);
      });
    }

    // Setup filters with manager-specific functionality
    function setupRiskFilters() {
      // Risk filters - make them passive (don't auto-trigger analysis)
      ['riskProductFilter','riskCategoryFilter','riskSeverityFilter','riskDateRange']
        .forEach(id => {
          const el = document.getElementById(id);
          if (el) el.addEventListener('change', () => {
            showToast('Filters changed â€” click "Analyze Risks" to refresh', 'info');
            // Enable the analyze button
            const analyzeBtn = document.querySelector('button[onclick="generateRiskAnalysis()"]');
            if (analyzeBtn) {
              analyzeBtn.disabled = false;
              analyzeBtn.style.opacity = '1';
            }
          });
        });

      // Forecast filters - mark as dirty but don't auto-generate
      ['productFilter', 'timeRange']
        .forEach(id => {
          const el = document.getElementById(id);
          if (el) el.addEventListener('change', () => {
            filtersDirty = true;
            showToast('Filters changed â€” click Generate to refresh', 'info');
            // Enable the generate button
            const generateBtn = document.querySelector('button[onclick="generateForecast()"]');
            if (generateBtn) {
              generateBtn.disabled = false;
              generateBtn.style.opacity = '1';
            }
          });
        });

      // Price filters - mark as dirty but don't auto-generate
      ['priceProductFilter', 'priceTimeRange']
        .forEach(id => {
          const el = document.getElementById(id);
          if (el) el.addEventListener('change', () => {
            showToast('Filters changed â€” click Generate Price Forecast to refresh', 'info');
            // Clear current price insights when filters change
            clearPriceInsights();
            // Enable the generate button
            const generateBtn = document.querySelector('button[onclick="generatePriceForecast()"]');
            if (generateBtn) {
              generateBtn.disabled = false;
              generateBtn.style.opacity = '1';
            }
          });
        });
    }

    // Helpers
    function formatDate(str) {
      const opts = { year: 'numeric', month: 'short', day: 'numeric' };
      return new Date(str).toLocaleDateString('en-US', opts);
    }

    function showToast(message, type='info') {
      const el = document.createElement('div');
      el.className = `toast ${type}`;
      el.innerHTML = `
        <i class="fas ${type === 'success' ? 'fa-check-circle' : type === 'error' ? 'fa-exclamation-circle' : 'fa-info-circle'}"></i>
        <span>${message}</span>
      `;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 3000);
    }

    // Export functions with branch-specific filenames
    async function exportForecast() {
      try {
        const branchName = MANAGER_BRANCH_NAME || 'branch';
        const date = new Date().toISOString().slice(0, 10);
        const filename = `forecast_${branchName.toLowerCase().replace(/\s+/g, '_')}_${date}.csv`;
        
        const response = await fetch('/manager/api/forecast/export?format=csv');
        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
          showToast('Forecast exported successfully', 'success');
        } else {
          showToast('Error exporting forecast', 'error');
        }
      } catch (error) {
        console.error('Export error:', error);
        showToast('Error exporting forecast', 'error');
      }
    }

    async function exportRiskReport() {
      try {
        const branchName = MANAGER_BRANCH_NAME || 'branch';
        const date = new Date().toISOString().slice(0, 10);
        const filename = `risk_report_${branchName.toLowerCase().replace(/\s+/g, '_')}_${date}.csv`;
        
        const response = await fetch('/manager/api/analytics/export?format=csv&type=risk');
        if (response.ok) {
          const blob = await response.blob();
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          window.URL.revokeObjectURL(url);
          document.body.removeChild(a);
          showToast('Risk report exported successfully', 'success');
        } else {
          showToast('Error exporting risk report', 'error');
        }
      } catch (error) {
        console.error('Export error:', error);
        showToast('Error exporting risk report', 'error');
      }
    }

    // Display detailed forecast information and stock preparation guide for manager
    async function displayForecastInformation(forecastData, branchId, productId) {
      try {
        console.log('DEBUG displayForecastInformation: Received data:', forecastData);
        
        // Get forecast values from the API response - handle manager API structure
        let forecastValues = [];
        let summary = {};
        let modelType = 'ARIMA';
        
        // Manager API returns: { forecast: { labels: [], forecast: [], actual: [] }, summary: {}, details: [] }
        if (forecastData.forecast) {
          // Check for forecast.forecast array (manager API format) - this is the primary source
          if (Array.isArray(forecastData.forecast.forecast) && forecastData.forecast.forecast.length > 0) {
            forecastValues = forecastData.forecast.forecast;
            console.log('DEBUG: Found forecast.forecast array with', forecastValues.length, 'values');
          } 
          // Check for forecast.forecast_values array
          else if (Array.isArray(forecastData.forecast.forecast_values) && forecastData.forecast.forecast_values.length > 0) {
            forecastValues = forecastData.forecast.forecast_values;
            console.log('DEBUG: Found forecast.forecast_values array with', forecastValues.length, 'values');
          }
          // Check if forecast itself is an array
          else if (Array.isArray(forecastData.forecast) && forecastData.forecast.length > 0) {
            forecastValues = forecastData.forecast;
            console.log('DEBUG: Found forecast as array with', forecastValues.length, 'values');
          }
          
          // Get model type
          modelType = forecastData.forecast.model_type || forecastData.model_info?.type || 'ARIMA';
        }
        
        // Try details array if forecast array is empty - this is important for manager API
        if (forecastValues.length === 0 && Array.isArray(forecastData.details) && forecastData.details.length > 0) {
          // Extract predicted_demand from details - manager API returns details with predicted_demand
          forecastValues = forecastData.details
            .map(item => {
              const value = item.predicted_demand || item.forecast || item.value || 0;
              return typeof value === 'number' ? value : parseFloat(value) || 0;
            })
            .filter(v => v > 0); // Filter out zeros
          console.log('DEBUG: Extracted forecast values from details array:', forecastValues.length);
        }
        
        // If forecast is directly in forecastData
        if (forecastValues.length === 0 && Array.isArray(forecastData.forecast_values) && forecastData.forecast_values.length > 0) {
          forecastValues = forecastData.forecast_values;
          console.log('DEBUG: Found forecast_values directly:', forecastValues.length);
        }
        
        // Last resort: check if we can get values from the chart data that was already applied
        if (forecastValues.length === 0 && demandChart && demandChart.data && demandChart.data.datasets) {
          const forecastDataset = demandChart.data.datasets.find(ds => ds.label === 'Forecast' || ds.label === 'Forecasted Demand');
          if (forecastDataset && Array.isArray(forecastDataset.data) && forecastDataset.data.length > 0) {
            forecastValues = forecastDataset.data
              .map(v => typeof v === 'number' ? v : parseFloat(v) || 0)
              .filter(v => v > 0);
            console.log('DEBUG: Extracted forecast values from chart data:', forecastValues.length);
          }
        }
        
        summary = forecastData.summary || {};
        
        console.log('DEBUG: Final forecastValues length:', forecastValues.length);
        console.log('DEBUG: Summary data:', summary);
        
        // If no forecast values, try to use summary data or show helpful message
        if (!forecastValues || forecastValues.length === 0) {
          console.warn('No forecast values found. Attempting to use summary data or show helpful information.');
          
          // Check if this is a "0 products" scenario
          const message = forecastData.message || '';
          const isZeroProducts = message.includes('0 products') || (message.includes('Generated') && message.includes('0'));
          
          // Also check if forecast_data array is empty
          const hasEmptyForecast = forecastData.forecast && 
            Array.isArray(forecastData.forecast.forecast) && 
            forecastData.forecast.forecast.length === 0;
          
          if (isZeroProducts || hasEmptyForecast) {
            // Show helpful message about why no forecast was generated
            const infoContent = document.getElementById('forecast-information-content');
            if (infoContent) {
              infoContent.innerHTML = `
                <div style="padding: 20px;">
                  <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #856404; font-size: 1rem;">âš ï¸ No Products Found for Forecast</h4>
                    <p style="margin: 0; color: #856404;">
                      The system could not find any products to generate a forecast for. This could be because:
                    </p>
                    <ul style="margin: 8px 0 0 20px; color: #856404;">
                      <li>No products are available in your branch inventory</li>
                      <li>The selected product filter doesn't match any products</li>
                      <li>Products exist but have no sales history</li>
                    </ul>
                  </div>
                  <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid #1a365d;">
                    <h4 style="margin: 0 0 8px 0; color: #1a365d; font-size: 1rem;">ðŸ’¡ How to Fix This</h4>
                    <ul style="margin: 8px 0 0 20px; color: #374151;">
                      <li>Go to <strong>Inventory</strong> and add products to your branch</li>
                      <li>Record some <strong>Sales</strong> transactions for the products</li>
                      <li>Try selecting "All Products" instead of a specific product</li>
                      <li>Wait a few days after recording sales to build historical data</li>
                    </ul>
                  </div>
                </div>
              `;
              document.getElementById('forecast-information').style.display = 'block';
            }
            return;
          }
          
          // Try to create forecast values from summary if available
          if (summary && (summary.avg_demand > 0 || summary.peak_quantity > 0)) {
            // Create a simple forecast array from summary
            const days = forecastData.model_info?.days_forecasted || summary.days_forecasted || 30;
            const baseDemand = summary.avg_demand || summary.peak_quantity || 50;
            forecastValues = Array(days).fill(baseDemand);
            console.log('DEBUG: Created forecast values from summary:', forecastValues.length, 'days, base demand:', baseDemand);
          } 
          // Try to use chart data one more time if summary doesn't work
          else if (demandChart && demandChart.data && demandChart.data.datasets) {
            const forecastDataset = demandChart.data.datasets.find(ds => 
              ds.label === 'Forecast' || 
              ds.label === 'Forecasted Demand' || 
              ds.label === 'Predicted Demand'
            );
            if (forecastDataset && Array.isArray(forecastDataset.data) && forecastDataset.data.length > 0) {
              forecastValues = forecastDataset.data
                .map(v => typeof v === 'number' && !isNaN(v) ? v : parseFloat(v) || 0)
                .filter(v => v > 0);
              if (forecastValues.length > 0) {
                console.log('DEBUG: Using chart data as forecast values:', forecastValues.length);
              }
            }
          }
          
          // If we still don't have values after all attempts, show error message
          if (!forecastValues || forecastValues.length === 0) {
            // Show error message but still display the section
            const infoContent = document.getElementById('forecast-information-content');
            if (infoContent) {
              infoContent.innerHTML = `
                <div style="padding: 20px;">
                  <div style="background: #fee2e2; border-left: 4px solid #e53e3e; padding: 16px; border-radius: 8px; margin-bottom: 16px;">
                    <h4 style="margin: 0 0 8px 0; color: #991b1b; font-size: 1rem;">âš ï¸ Forecast data is incomplete</h4>
                    <p style="margin: 0; color: #991b1b;">
                      The forecast could not be generated because there is insufficient data. The forecast requires historical sales transactions to generate accurate predictions.
                    </p>
                  </div>
                  <div style="background: #e8f5e9; padding: 16px; border-radius: 8px; border-left: 4px solid #1a365d;">
                    <h4 style="margin: 0 0 8px 0; color: #1a365d; font-size: 1rem;">ðŸ’¡ What You Can Do</h4>
                    <ul style="margin: 8px 0 0 20px; color: #374151;">
                      <li>Ensure you have recorded sales transactions for the selected product</li>
                      <li>Wait for at least 7-14 days of sales data to build a reliable forecast</li>
                      <li>Try selecting a different product that has more sales history</li>
                      <li>Check that sales are being recorded correctly in the Sales page</li>
                    </ul>
                  </div>
                </div>
              `;
              document.getElementById('forecast-information').style.display = 'block';
            }
            return;
          }
          // If we successfully extracted values from summary or chart, continue to show full information
          console.log('DEBUG: Successfully extracted forecast values, proceeding to display full information');
        }
        
        // Get product name from details if available
        let productName = 'Unknown Product';
        if (Array.isArray(forecastData.details) && forecastData.details.length > 0) {
          productName = forecastData.details[0].product_name || 'Unknown Product';
        }
        
        // Fetch current inventory for this branch and product
        let currentStock = 0;
        
        try {
          const branchIdParam = branchId || MANAGER_BRANCH_ID;
          const inventoryUrl = '/manager/api/inventory' + (branchIdParam ? `?branch_id=${branchIdParam}` : '');
          const inventoryResponse = await fetch(inventoryUrl);
          const inventoryData = await inventoryResponse.json().catch(() => ({ items: [] }));
          
          if (inventoryData.ok && inventoryData.items) {
            // Find the specific product if productId is provided
            const productItem = productId 
              ? inventoryData.items.find(item => item.product_id == productId || item.id == productId)
              : inventoryData.items.find(item => (item.product_name || item.name) === productName) || inventoryData.items[0];
            
            if (productItem) {
              currentStock = productItem.stock_kg || productItem.stock || 0;
              // Update product name if we found it in inventory
              if (!productName || productName === 'Unknown Product') {
                productName = productItem.product_name || productItem.name || 'Unknown Product';
              }
            }
          }
        } catch (error) {
          console.error('Error fetching inventory:', error);
        }
        
        const branchName = MANAGER_BRANCH_NAME || 'Your Branch';
        
        // Calculate forecast statistics
        const avgDailyDemand = forecastValues.length > 0 
          ? forecastValues.reduce((a, b) => a + b, 0) / forecastValues.length 
          : 0;
        const totalForecast = forecastValues.reduce((a, b) => a + b, 0);
        const maxDailyDemand = Math.max(...forecastValues);
        const minDailyDemand = Math.min(...forecastValues);
        const forecastDays = forecastValues.length;
        
        // Calculate stock recommendations
        const recommendedStock = Math.ceil(totalForecast * 1.2); // 20% buffer
        const stockShortage = recommendedStock - currentStock;
        const daysOfStock = currentStock > 0 && avgDailyDemand > 0 
          ? Math.floor(currentStock / avgDailyDemand) 
          : 0;
        
        // Determine stock status
        let stockStatus = 'good';
        let stockStatusText = 'Adequate';
        let stockStatusColor = '#1a365d';
        if (stockShortage > 0) {
          stockStatus = stockShortage > totalForecast * 0.5 ? 'critical' : 'warning';
          stockStatusText = stockShortage > totalForecast * 0.5 ? 'Critical Shortage' : 'Low Stock';
          stockStatusColor = stockShortage > totalForecast * 0.5 ? '#e53e3e' : '#f59e0b';
        }
        
        // Get accuracy score if available
        const accuracyScore = summary.accuracy_score || forecastData.forecast?.accuracy_score || 0.75;
        
        const infoContent = document.getElementById('forecast-information-content');
        infoContent.innerHTML = `
          <div style="display: grid; grid-template-columns: 1fr; gap: 24px;">
            <!-- What the Forecast Means -->
            <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; border-left: 4px solid #1a365d;">
              <h4 style="margin: 0 0 12px 0; color: #1a365d; font-size: 1.1rem; font-weight: 700;">
                ðŸ“Š What This Forecast Means
              </h4>
              <div style="color: #374151; line-height: 1.8;">
                <p style="margin: 0 0 12px 0;">
                  <strong>The forecasted days represent:</strong> The predicted daily demand (in kilograms) for the next <strong>${forecastDays} days</strong> for <strong>${productName}</strong> at <strong>${branchName}</strong>, based on historical sales data analyzed using the <strong>${modelType}</strong> model.
                </p>
                <p style="margin: 0 0 12px 0;">
                  <strong>How it works:</strong> The system analyzes your branch's past sales transactions to identify patterns, trends, and seasonal variations. It then predicts how much rice customers will likely purchase each day for the selected period.
                </p>
                <p style="margin: 0;">
                  <strong>Model accuracy:</strong> This forecast has an accuracy of <strong>${(accuracyScore * 100).toFixed(1)}%</strong>, meaning the predictions are reliable for planning your inventory needs.
                </p>
              </div>
            </div>
            
            <!-- Stock Preparation Recommendations -->
            <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; border-left: 4px solid ${stockStatusColor};">
              <h4 style="margin: 0 0 12px 0; color: ${stockStatusColor}; font-size: 1.1rem; font-weight: 700;">
                ðŸ“¦ Stock Preparation Recommendations for ${branchName}
              </h4>
              <div style="color: #374151; line-height: 1.8;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 16px;">
                  <div style="background: white; padding: 12px; border-radius: 8px;">
                    <strong style="color: #64748b; font-size: 0.9rem;">Current Stock</strong>
                    <div style="font-size: 1.3rem; font-weight: 700; color: #374151;">${currentStock.toFixed(2)} kg</div>
                  </div>
                  <div style="background: white; padding: 12px; border-radius: 8px;">
                    <strong style="color: #64748b; font-size: 0.9rem;">Forecasted Demand</strong>
                    <div style="font-size: 1.3rem; font-weight: 700; color: #374151;">${totalForecast.toFixed(2)} kg</div>
                  </div>
                  <div style="background: white; padding: 12px; border-radius: 8px;">
                    <strong style="color: #64748b; font-size: 0.9rem;">Recommended Stock</strong>
                    <div style="font-size: 1.3rem; font-weight: 700; color: #1a365d;">${recommendedStock.toFixed(2)} kg</div>
                  </div>
                  <div style="background: white; padding: 12px; border-radius: 8px;">
                    <strong style="color: #64748b; font-size: 0.9rem;">Stock Status</strong>
                    <div style="font-size: 1.1rem; font-weight: 700; color: ${stockStatusColor};">${stockStatusText}</div>
                  </div>
                </div>
                
                ${stockShortage > 0 ? `
                  <div style="background: ${stockStatusColor === '#e53e3e' ? 'rgba(229, 62, 62, 0.1)' : 'rgba(245, 158, 11, 0.1)'}; padding: 16px; border-radius: 8px; margin-bottom: 12px; border: 1px solid ${stockStatusColor};">
                    <strong style="color: ${stockStatusColor}; display: block; margin-bottom: 8px;">âš ï¸ Action Required</strong>
                    <p style="margin: 0; color: #374151;">
                      You need to restock <strong>${stockShortage.toFixed(2)} kg</strong> of ${productName} to meet the forecasted demand with a 20% safety buffer. 
                      Current stock will only last approximately <strong>${daysOfStock} days</strong> at average demand. Consider placing a purchase order soon.
                    </p>
                  </div>
                ` : `
                  <div style="background: rgba(26, 54, 93, 0.1); padding: 16px; border-radius: 8px; margin-bottom: 12px; border: 1px solid #1a365d;">
                    <strong style="color: #1a365d; display: block; margin-bottom: 8px;">âœ… Stock Level Adequate</strong>
                    <p style="margin: 0; color: #374151;">
                      Current stock for ${productName} is sufficient to meet forecasted demand. Monitor daily sales and replenish when stock falls below recommended levels.
                    </p>
                  </div>
                `}
                
                <div style="background: #e8f5e9; padding: 16px; border-radius: 8px;">
                  <strong style="color: #1a365d; display: block; margin-bottom: 8px;">ðŸ’¡ Stock Preparation Strategy for ${branchName}</strong>
                  <ul style="margin: 8px 0 0 0; padding-left: 20px; color: #374151;">
                    <li style="margin-bottom: 8px;">Prepare <strong>${recommendedStock.toFixed(2)} kg</strong> total stock of ${productName} to cover the next ${forecastDays} days</li>
                    <li style="margin-bottom: 8px;">Plan for peak daily demand of <strong>${maxDailyDemand.toFixed(2)} kg</strong> (highest predicted day)</li>
                    <li style="margin-bottom: 8px;">Maintain minimum daily stock of <strong>${Math.ceil(maxDailyDemand * 3)} kg</strong> (3 days of peak demand as safety buffer)</li>
                    <li style="margin-bottom: 0;">Schedule restock orders when stock falls below <strong>${Math.ceil(avgDailyDemand * 7)} kg</strong> (1 week of average demand)</li>
                  </ul>
                </div>
              </div>
            </div>
            
            <!-- Forecast Details -->
            <div style="background: #f8f9fa; padding: 20px; border-radius: 12px; border-left: 4px solid #3b82f6;">
              <h4 style="margin: 0 0 12px 0; color: #3b82f6; font-size: 1.1rem; font-weight: 700;">
                ðŸ“ˆ Forecast Details for ${productName}
              </h4>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; color: #374151;">
                <div>
                  <strong style="color: #64748b; font-size: 0.9rem;">Average Daily Demand</strong>
                  <div style="font-size: 1.1rem; font-weight: 600;">${avgDailyDemand.toFixed(2)} kg/day</div>
                </div>
                <div>
                  <strong style="color: #64748b; font-size: 0.9rem;">Peak Daily Demand</strong>
                  <div style="font-size: 1.1rem; font-weight: 600;">${maxDailyDemand.toFixed(2)} kg</div>
                </div>
                <div>
                  <strong style="color: #64748b; font-size: 0.9rem;">Minimum Daily Demand</strong>
                  <div style="font-size: 1.1rem; font-weight: 600;">${minDailyDemand.toFixed(2)} kg</div>
                </div>
                <div>
                  <strong style="color: #64748b; font-size: 0.9rem;">Model Accuracy</strong>
                  <div style="font-size: 1.1rem; font-weight: 600;">${(accuracyScore * 100).toFixed(1)}%</div>
                </div>
              </div>
            </div>
          </div>
        `;
        
        // Show the information section
        const infoSection = document.getElementById('forecast-information');
        if (infoSection) {
          infoSection.style.display = 'block';
          console.log('DEBUG: Forecast information section displayed');
        } else {
          console.error('DEBUG: forecast-information element not found!');
        }
      } catch (error) {
        console.error('Error displaying forecast information:', error);
        // Show error message in the section
        const infoContent = document.getElementById('forecast-information-content');
        const infoSection = document.getElementById('forecast-information');
        if (infoContent && infoSection) {
          infoContent.innerHTML = `
            <div style="padding: 20px; text-align: center; color: #666;">
              <p style="color: #e53e3e; font-weight: 600;">âš ï¸ Error displaying forecast information</p>
              <p>${error.message || 'An unexpected error occurred'}</p>
              <p style="font-size: 0.9rem; margin-top: 10px; color: #999;">Please check the browser console for details.</p>
            </div>
          `;
          infoSection.style.display = 'block';
        }
      }
    }

    // Update title and header based on branch selection
    function updateBranchTitle() {
      const branchName = '{{ branch_name if branch_name else "" }}' || new URLSearchParams(window.location.search).get('branch_name');
      const branchId = {{ branch_id if branch_id else 'null' }} || new URLSearchParams(window.location.search).get('branch');
      
      if (branchName) {
        const decodedBranchName = decodeURIComponent(branchName);
        document.getElementById('pageTitle').textContent = `Forecast - G.M.C. Rice Warehouse - ${decodedBranchName} Branch`;
        document.getElementById('branchTitle').textContent = `G.M.C. Rice Warehouse - ${decodedBranchName} Branch`;
        
        // Update all navigation links to preserve branch parameters
        updateNavigationLinks(branchId, branchName);
      }
    }

    // Update navigation links to include branch parameters
    function updateNavigationLinks(branchId, branchName) {
      const navLinks = document.querySelectorAll('.nav-main a[href]');
      navLinks.forEach(link => {
        const currentHref = link.getAttribute('href');
        if (currentHref && !currentHref.includes('branch=')) {
          const separator = currentHref.includes('?') ? '&' : '?';
          link.href = `${currentHref}${separator}branch=${branchId}&branch_name=${encodeURIComponent(branchName)}`;
        }
      });
    }

    // Call the function when page loads
    document.addEventListener('DOMContentLoaded', updateBranchTitle);
  </script>
</body>
</html>
